[{"id":"bad0988fe1e449dbb6a39d8bce9e4907","title":"Java 面试题记录","content":"Java 基础String、StringBuffer 和 StringBuilder 的区别String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个final类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。\nStringBuffer和StringBuilder他们两都继承了AbstractStringBuilder抽象类，他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuffer和 StringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n\nHashMap 与 ConcurrentHashMap 的异同\n都是 key-value 形式的存储数据；\nHashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的；\nHashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑 树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红 黑树查询速度快；\nHashMap 初始数组大小为 16（默认），当出现扩容的时候，以 0.75 * 数组大小的方式进行扩 容；\nConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry， Segment 数组大小默认是 16，2 的 n 次方；JDK 1.8 之后，采用 Node + CAS + Synchronized来保证并发安全进行实现。\n\n\nArrayList源码分析当实例化ArrayList对象不指定容量时，默认初始容量为10。\nboolean add(E e)源码\njava public boolean add(E e) &#123;\n     ensureCapacityInternal(size + 1);  // Increments modCount!!\n     elementData[size++] = e;\n     return true;\n &#125;添加元素先判断容量是否足够，当元素数量大于数组容量时进行1.5倍扩容、数组拷贝。\nE get(int index)源码\njava public E get(int index) &#123;\n     rangeCheck(index);\n\n     return elementData(index);\n &#125;查询获取元素时先检查下标是否越界，然后直接根据下标获取元素。\nE set(int index, E element)源码\njava public E set(int index, E element) &#123;\n     rangeCheck(index);\n\n     E oldValue = elementData(index);\n     elementData[index] = element;\n     return oldValue;\n &#125;先检查下标是否越界，更改指定下标的数据，并把旧数据返回。\nvoid add(int index, E element)源码\njava public void add(int index, E element) &#123;\n     rangeCheckForAdd(index);\n\n     ensureCapacityInternal(size + 1);  // Increments modCount!!\n     System.arraycopy(elementData, index, elementData, index + 1,\n                      size - index);\n     elementData[index] = element;\n     size++;\n &#125;先检查下标是否越界，再判断容量是否足够，在指定位置插入指定的元素并将当前位于该位置及以后的元素向后移动。\nE remove(int index)源码\njava public E remove(int index) &#123;\n     rangeCheck(index);\n\n     modCount++;\n     E oldValue = elementData(index);\n\n     int numMoved = size - index - 1;\n     if (numMoved &gt; 0)\n         System.arraycopy(elementData, index+1, elementData, index,\n                          numMoved);\n     elementData[--size] = null; // clear to let GC do its work\n\n     return oldValue;\n &#125;先检查下标是否越界，删除此列表中指定位置的元素，将任何后续元素向前移动，并把删除的数据返回。\nvoid grow(int minCapacity)源码\njavaprivate void grow(int minCapacity) &#123;\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n&#125;以当前容量的1.5倍增加容量，以确保它至少可以容纳最小容量参数指定的元素数量。\n\nArrayList优缺点及使用场景优点：基于数组来实现，非常适合随机读。\n缺点：\n\n原理就是底层基于数组来实现，java里面数组都是定长数组，长度是固定的。当加入数据达到一定程度后，会进行数组扩容 ，就会搞一个更大的数组，把以前的数组元素拷贝到新的数组里面去。\n往ArrayList中间插入一个元素，性能比较差，会导致后面的大量的元素挪动一个位置。\n\n使用场景：有一批数据，查询出来，灌入ArrayList中，后面不会频繁插入元素了，主要就是遍历这个集合，或者是通过索引随机读取某个元素，这种使用ArrayList还是比较合适的。\n\nLinkedList优缺点及使用场景LinkedList底层是基于双向链表来实现的，一个节点连着另外一个节点。\n优点：就是非常适合各种元素频繁的插入里面去。\n缺点：不太适合在随机的位置，获取某个随机的位置的元素。\n使用场景：适合频繁插入和删除某个元素，LinkedList其实是可以当做队列来用的。如果要在内存里实现一个基本的队列的话，可以用LinkedList。\n\nHashMap源码分析HashMap的静态常量\njava/**\n * 默认的初始容量-必须是二的幂\n */\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16\n\n/**\n * 最大容量，如果其中一个带有参数的构造函数隐式指定了更高的值，则使用该容量。必须是二次方&lt;= 1&lt;&lt;30\n */\nstatic final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;\n\n/**\n * 在构造函数中未指定时使用的负载系数\n */\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n/**\n * 使用树而不是链表作为存储的计数阈值。当向至少有这么多节点的链表添加元素时，链表会转换为树。\n */\nstatic final int TREEIFY_THRESHOLD = 8;\n\n/**\n * 在调整大小操作期间，用于红黑树转链表的最小计数阈值。应小于TREEIFY_THRESHOLD，并且最多为6，以便在移除时进行收缩检测。\n */\nstatic final int UNTREEIFY_THRESHOLD = 6;\n\n/**\n * 可以树化的最小table数组容量。（否则，如果一个链表中的节点太多，则会调整表的大小。）\n */\nstatic final int MIN_TREEIFY_CAPACITY = 64;HashMap的构造方法源码\njavapublic HashMap(int initialCapacity, float loadFactor) &#123;\n    if (initialCapacity &lt; 0)\n        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                           initialCapacity);\n    if (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                           loadFactor);\n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\n&#125;\n\npublic HashMap(int initialCapacity) &#123;\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n&#125;\n\npublic HashMap() &#123;\n    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n&#125;HashMap的hash(Object key)方法源码\njavastatic final int hash(Object key) &#123;\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;计算key的hashCode()与自身无符号右移16位，然后异或计算得到的值。通过移位异或，将高16位的影响扩散到低16位，增加随机性，来减少发生哈希冲突的几率。\nHashMap的get(Object key)及getNode(int hash, Object key)方法源码\njavapublic V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n&#125;\n\nfinal Node&lt;K,V&gt; getNode(int hash, Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;\n        (first = tab[(n - 1) &amp; hash]) != null) &#123;\n        if (first.hash == hash &amp;&amp; // always check first node\n            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))\n            return first;\n        if ((e = first.next) != null) &#123;\n            if (first instanceof TreeNode)\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n            do &#123;\n                if (e.hash == hash &amp;&amp;\n                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                    return e;\n            &#125; while ((e = e.next) != null);\n        &#125;\n    &#125;\n    return null;\n&#125;getNode(int hash, Object key)：根据hash寻址找到指定key在table数组的位置上的node，判断这个node是不是这个key，如果是直接返回这个节点。不是的话，先判断next节点是不是TreeNode节点，如果是则进行红黑树相关的查找。如果也不是TreeNode节点，则进行链表的遍历查找。\nHashMap的put(K key, V value)及putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)方法源码\njavapublic V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    if ((p = tab[i = (n - 1) &amp; hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    else &#123;\n        Node&lt;K,V&gt; e; K k;\n        if (p.hash == hash &amp;&amp;\n            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n            e = p;\n        else if (p instanceof TreeNode)\n            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n            for (int binCount = 0; ; ++binCount) &#123;\n                if ((e = p.next) == null) &#123;\n                    p.next = newNode(hash, key, value, null);\n                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                &#125;\n                if (e.hash == hash &amp;&amp;\n                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                    break;\n                p = e;\n            &#125;\n        &#125;\n        if (e != null) &#123; // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        &#125;\n    &#125;\n    ++modCount;\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n&#125;如果当前对象是不是刚被创建，则进行table数组、阈值相关的初始化。然后根据hash寻址算法计算出在table数组的下标，判断当前位置是否有数据。如果没有数据的话，直接把数据放在当前位置。如果已经存在数据，则判断是不是当前key，是的话就更新value值。不是的话判断当前节点是不是TreeNode节点，是的话进行红黑树相关的操作。如果不是TreeNode节点，就进行链表的处理。循环链表，如果可以在链表找到key相等的节点则更新，否则就在链表最后添加新的节点。如果链表长度超过8，则链表转化为红黑树。\n\n","slug":"Java-面试题记录","date":"2023-10-16T15:05:56.000Z","categories_index":"","tags_index":"Java 面试","author_index":"Aurora"},{"id":"217593595b5cc111881f13eb6a828c9a","title":"Nginx 学习记录","content":"安装\n下载\n\nwget https://nginx.org/download/nginx-1.24.0.tar.gz\n\n\n解压安装\n\ntar -zxvf nginx-1.13.0.tar.gz -C ./\n\n\n安装编译工具及库文件\n\nyum -y install gcc gcc-c++ ncurses-devel perl pcre pcre-devel zlib gzip zlib-devel\n\n\n编译安装\n\n./configure --prefix=/usr/local/nginx\nmake &amp;&amp; make install\n\n\n\n\n基础命令\n启动Nginx（切换到安装目录下的sbin文件夹下）\n./nginx\n\n\n指定配置文件启动Nginx\n./nginx -c ../conf/nginx.conf\n\n\n重新读取配置文件\n./nginx -s reload\n\n\n检查配置文件是否正确\n./nginx -t\n\n\n停止Nginx\n./nginx -s stop：快速关闭，不管有没有正在处理的请求\n./nginx -s quit：优雅的关闭方式，Nginx在退出前完成已经接受的连接请求\n\n\n重新打开日志\n./nginx -s reopen\n\n\n\n\n信号控制Nginx允许我们通过信号来控制主进程，用信号的方式可以达到不影响现有连接的目的。具体语法：kill -信号选项 nginx的主进程号\n\n信号类型\n\nINT，TERM：快速关闭信号\nQUIT：从容关闭信号\nHUP：从容重启信号，一般用于修改配置文件后，重启\nUSR1：重读日志，一般用于日志的切割\nUSR2：平滑升级信号\nWINCH：从容关闭旧进程\n\n\n\n平滑升级\n下载高版本并完成解压。\n\n执行编译。\n\n./configure &amp;&amp; make\n\n\n备份低版本nginx可执行文件，将objs目录下编译生成的高版本nginx复制到低版本nginx安装路径下的sbin目录下。\n\n执行信号平滑升级\n\ntxtkill -USR2 `cat /usr/local/nginx/logs/nginx.pid`\n给nginx发送USR2信号后，nginx会将logs&#x2F;nginx.pid文件重命名为nginx.pid.oldbin，然后用新的可执行文件启动一个新的nginx主进程和对应的工作进程，并新建一个新的nginx.pid保存新的主进程号。\n\n平滑升级也可以通过执行 make upgrade。\n\n\n\n优雅关闭旧的工作进程\n\ntxtkill -WINCH `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n旧的主进程号收到WINCH信号后，将旧进程号管理的旧的工作进程优雅的关闭。即一段时间后旧的工作进程全部关闭，只有新的工作进程在处理请求连接。这时，依然可以恢复到旧的进程服务，因为旧的进程的监听socket还未停止。\n\n\n\n中途停止升级，回滚到旧的nginx\n\ntxtkill -HUP `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n给旧的主进程号发送HUP命令，此时nginx不重新读取配置文件的情况下重新启动旧主进程的工作进程。\n\n\n\n升级完成，退出旧的主进程。\n\ntxtkill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n给旧的主进程发送QUIT信号后，旧的主进程退出，并移除logs&#x2F;nginx.pid.oldbin文件，nginx的升级完成。\n\n\n\n\n\n安装模块在nginx源码目录下运行。\ntxt./configure --add-module=模块目录\nmake备份低版本nginx可执行文件，将objs目录下编译生成的高版本nginx复制到低版本nginx安装路径下的sbin目录下。\n全新安装执行：\ntxtmake install平滑升级执行：\ntxtmake upgrade \nmake clean \n配置连接数worker_processes：表示开启nginx的worker进程的个数，nginx启动会开两种进程，master进程用来管理调度，worker进程用来处理请求；\n上面表示两种设置方法，比如\n方法一：worker_processes auto;\n　　表示设置服务器cpu核数匹配开启nginx开启的worker进程数\n　　查看cpu核数：cat &#x2F;proc&#x2F;cpuinfo\n方法二：nginx设置cpu亲和力\n　　worker_processes 8;\n　　worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;\n　　00000001表示启用第一个CPU内核，00000010表示启用第二个CPU内核，以此类推\nworker_cpu_affinity：表示开启八个进程，第一个进程对应着第一个CPU内核，第二个进程对应着第二个CPU内核，以此类推。\n这种设置方法更高效，因将每个cpu核提供给固定的worker进程服务，减少cpu上下文切换带来的资源浪费。\n\nlocation配置详解\n语法规则： 指令 前缀 uri\n\n\nlocation [=|~|~*|^~] /uri/ &#123; … &#125;\n\n\n\n\nlocation区分普通匹配和正则匹配\n\n用前缀 “” 和 “”修饰的为正则匹配~   前缀表示区分大小写的正则匹配~  前缀表示不区分大小写的正则匹配\n除上面修饰的前缀（“&#x3D;” 和 “^”，或没有前缀修饰）都为普通匹配&#x3D;   前缀表示精确匹配^  前缀表示uri以某个常规字符串开头，可以理解为url的普通匹配\n\n\n匹配的原则\n\n普通匹配：优先原则—-&gt;最大前缀匹配原则; 顺序无关\n正则匹配：为顺序匹配，优先原则：谁在前面 就匹配谁；顺序相关\n如果location有普通匹配也有正则匹配，那匹配的原则为：\n首先匹配 &#x3D;，其次匹配^~, 其次是按文件中顺序的正则匹配，不带前缀普通匹配，最后是交给 &#x2F; 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。\n\n\n\n\n负载均衡nginx实现负载均衡原理，用户访问首先访问到nginx服务器，然后nginx服务器再从应用服务器集群中选择压力比较小的服务器，然后将该访问请求引向该服务器。如应用服务器集群中某一台服务器崩溃，那么从待选择服务器列表中将该服务器删除，也就是说一个服务器崩溃了，那么nginx服务器不会把请求引向到该服务器。\ntxtserver &#123;\n    listen       80;\n    server_name  192.168.50.1;\n     location / &#123;\n        proxy_pass http://test;\n    &#125;\n&#125;\n随机轮询\n\ntxtupstream test &#123;\n    server 192.168.5.140:8080;\n    server 192.168.5.141:8080;\n&#125;\n\n\n\n权重\n\ntxtupstream test &#123;\n    server 192.168.5.140:8080 weight=5;\n    server 192.168.5.141:8080 weight=10;\n&#125;\n\n\nip_hash\n\ntxtupstream test &#123;\n    ip_hash;\n    server 192.168.5.140:8080;\n    server 192.168.5.141:8080;\n&#125;\n\n\n\n\nnginx全局变量\n$args ：                     #这个变量等于请求行中的参数，同$query_string\n$content_length ：    #请求头中的Content-length字段。\n$content_type ：       #请求头中的Content-Type字段。\n$document_root ：   #当前请求在root指令中指定的值。\n$host ：                     #请求主机头字段，否则为服务器名称。\n$http_user_agent ：  #客户端agent信息\n$http_cookie ：          #客户端cookie信息\n$limit_rate ：              #这个变量可以限制连接速率。\n$request_method ：   #客户端请求的动作，通常为GET或POST。\n$remote_addr ：         #客户端的IP地址。\n$remote_port ：          #客户端的端口。\n$remote_user ：         #已经经过Auth Basic Module验证的用户名。\n$request_filename ： #当前请求的文件路径，由root或alias指令与URI请求生成。\n$scheme ：                #HTTP方法（如http，https）。\n$server_protocol ：    #请求使用的协议，通常是HTTP&#x2F;1.0或HTTP&#x2F;1.1。\n$server_addr ：         #服务器地址，在完成一次系统调用后可以确定这个值。\n$server_name ：       #服务器名称。\n$server_port ：          #请求到达服务器的端口号。\n$request_uri ：          #包含请求参数的原始URI，不包含主机名，如：”&#x2F;foo&#x2F;bar.php?arg&#x3D;baz”。\n$uri ：                        #不带请求参数的当前URI，$uri不包含主机名，如”&#x2F;foo&#x2F;bar.html”。\n$document_uri ：      #与$uri相同\n\n\n附录：配置文件nginx#以哪个用户，运行nginx应用\n#nobody是个低权限用户，为了安全\n#user nobody;\n\n#nginx进程数 启动进程,通常设置成 cpu的核数 查看cpu核数\n# cat /proc/cpuinfo\nworker_processes  1;\n\n#全局错误日志 \n#nginx的error_log类型如下（从左到右：debug最详细 crit最少）： \n#[ debug | info | notice | warn | error | crit ] \n#例如：error_log logs/nginx_error.log  crit; \n#解释：日志文件存储在nginx安装目录下的 logs/nginx_error.log ，错误类型为 crit ，也就是记录最少错误信息； \nerror_log  logs/error.log;\nerror_log  logs/notice.log  notice;\nerror_log  logs/info.log  info;\n\n#PID文件，记录当前启动的nginx的进程ID\npid        logs/nginx.pid;\n\n#这个参数表示worker进程最多能打开的文件句柄数，基于liunx系统ulimit设置\n#查看系统文件句柄数最大值：ulimit -n\n#Linux一切皆文件，所有请求过来最终目的访问文件，所以该参数值设置等同于liunx系统ulimit设置为优\n#可以通过linux命令设置  最大的文件句柄数65535\nworker_rlimit_nofile 65535;\n\n#工作模式及连接数上限\nevents &#123;\n   #网络模型高效(相当于建立索引查找结果)，nginx配置应该启用该参数\n   #但是仅用于linux2.6以上内核,可以大大提高nginx的性能\n   use   epoll;             \n   #该参数表示设置一个worker进程最多开启多少线程数\n   #优化设置应该等同于worker_rlimit_nofile设置值，表明一个线程处理一个http请求，同时可以处理一个文件数，各个模块之间协调合作不等待。\n   worker_connections  65535;\n&#125;\n\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\nhttp &#123;\n    #设定mime类型,类型由mime.type文件定义\n    #MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来#打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n    #设定日志格式\n    log_format  main  &#39;[$remote_addr] - [$remote_user] [$time_local] &quot;$request&quot; &#39;\n        &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n        &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n    access_log    /var/log/nginx/access.log;\n\n    #sendfile 开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n    sendfile        on;\n    tcp_nopush     on; #防止网络阻塞\n    tcp_nodelay        on; #防止网络阻塞\n\n    #连接超时时间\n    #keepalive_timeout  0;  \n    keepalive_timeout  65; #长连接超时时间，单位是秒\n\n    #开启gzip压缩\n    gzip  on;\n    gzip_disable &quot;MSIE [1-6]\\.&quot;; # IE6及以下禁止压缩 \n    gzip_min_length 1k; #最小压缩文件大小\n    gzip_buffers 4 16k; #压缩缓冲区\n    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n    gzip_comp_level 2; #压缩等级\n    gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型\n    gzip_vary on; #给CDN和代理服务器使用，针对相同url，可以根据头信息返回压缩和非压缩副本\n\n    #设定请求缓冲\n    client_header_buffer_size    1k;   #上传文件大小限制\n    large_client_header_buffers  4 4k;  #设定请求缓存\n\n    #设定负载均衡的服务器列表\n    upstream mysvr &#123;\n        #weigth参数表示权值，权值越高被分配到的几率越大\n        server 192.168.8.1x:3128 weight=5;\n        server 192.168.8.2x:80  weight=1;\n        server 192.168.8.3x:80  weight=6;\n    &#125;\n\n    upstream mysvr2 &#123;\n        #weigth参数表示权值，权值越高被分配到的几率越大\n        server 192.168.8.x:80  weight=1;\n        server 192.168.8.x:80  weight=6;\n    &#125;\n\n    #虚拟主机的配置\n    server &#123;\n        #侦听80端口\n        listen       80;\n        #设置编码\n        #charset koi8-r;\n\n        #定义使用www.xx.com访问 域名可以有多个，用空格隔开\n        server_name  www.xx.com;\n\n        #设定本虚拟主机的访问日志\n        access_log  logs/www.xx.com.access.log  main;\n\n        #默认请求\n        location / &#123;\n            root   /root;      #定义服务器的默认网站根目录位置\n            index index.php index.html index.htm;   #定义首页索引文件的名称\n\n            proxy_pass  http://mysvr ;#请求转向mysvr 定义的服务器列表\n\n            client_max_body_size 10m;    #允许客户端请求的最大单文件字节数\n            client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数，\t\n\n            #以下是一些反向代理的配置可删除.\n\n            proxy_redirect off;\n\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_connect_timeout 90;  #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_send_timeout 90;     #后端服务器数据回传时间(代理发送超时)\n            proxy_read_timeout 90;     #连接成功后，后端服务器响应时间(代理接收超时)\n            proxy_buffer_size 4k;      #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            proxy_buffers 4 32k;       #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置\n            proxy_busy_buffers_size 64k;    #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n\n        &#125;\n\n        # 定义错误提示页面\n        error_page   500 502 503 504 /50x.html; \n        location = /50x.html &#123;\n            root   /root;\n        &#125;\n\n        #本地动静分离反向代理配置\n        #所有jsp的页面均交由tomcat处理\n        location ~ .(jsp|jspx|do)?$ &#123;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://127.0.0.1:8080;\n        &#125;\n\n        #静态文件，nginx自己处理\n        location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;\n            root /var/www/virtual/htdocs;\n            #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。\n            expires 30d;\n        &#125;\n\n        #设定查看Nginx状态的地址\n        location /NginxStatus &#123;\n            stub_status            on;\n            access_log             on;\n            auth_basic             &quot;NginxStatus&quot;;\n            auth_basic_user_file  conf/htpasswd;\n            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。\n        &#125;\n        #禁止访问 .htxxx 文件\n        location ~ /\\.ht &#123;\n            deny all;\n        &#125;\n\n    &#125;\n&#125;\n","slug":"Nginx-学习记录","date":"2023-10-16T14:50:22.000Z","categories_index":"","tags_index":"Nginx","author_index":"Aurora"},{"id":"79b60e240085d4bb70ab66eeea0e147e","title":"测试文章","content":"第一章内容。\n\n第二章内容。\n\n内容结束。\n","slug":"测试文章","date":"2023-10-16T14:04:05.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deployMore info: Deployment\n","slug":"hello-world","date":"2023-10-16T13:47:37.421Z","categories_index":"","tags_index":"","author_index":"Aurora"}]