[{"id":"217593595b5cc111881f13eb6a828c9a","title":"Nginx 学习记录","content":"安装\n下载\n\nwget https://nginx.org/download/nginx-1.24.0.tar.gz\n\n\n解压安装\n\ntar -zxvf nginx-1.13.0.tar.gz -C ./\n\n\n安装编译工具及库文件\n\nyum -y install gcc gcc-c++ ncurses-devel perl pcre pcre-devel zlib gzip zlib-devel\n\n\n编译安装\n\n./configure --prefix=/usr/local/nginx\nmake &amp;&amp; make install\n\n\n\n\n基础命令\n启动Nginx（切换到安装目录下的sbin文件夹下）\n./nginx\n\n\n指定配置文件启动Nginx\n./nginx -c ../conf/nginx.conf\n\n\n重新读取配置文件\n./nginx -s reload\n\n\n检查配置文件是否正确\n./nginx -t\n\n\n停止Nginx\n./nginx -s stop：快速关闭，不管有没有正在处理的请求\n./nginx -s quit：优雅的关闭方式，Nginx在退出前完成已经接受的连接请求\n\n\n重新打开日志\n./nginx -s reopen\n\n\n\n\n信号控制Nginx允许我们通过信号来控制主进程，用信号的方式可以达到不影响现有连接的目的。具体语法：kill -信号选项 nginx的主进程号\n\n信号类型\n\nINT，TERM：快速关闭信号\nQUIT：从容关闭信号\nHUP：从容重启信号，一般用于修改配置文件后，重启\nUSR1：重读日志，一般用于日志的切割\nUSR2：平滑升级信号\nWINCH：从容关闭旧进程\n\n\n\n平滑升级\n下载高版本并完成解压。\n\n执行编译。\n\n./configure &amp;&amp; make\n\n\n备份低版本nginx可执行文件，将objs目录下编译生成的高版本nginx复制到低版本nginx安装路径下的sbin目录下。\n\n执行信号平滑升级\n\ntxtkill -USR2 `cat /usr/local/nginx/logs/nginx.pid`\n给nginx发送USR2信号后，nginx会将logs&#x2F;nginx.pid文件重命名为nginx.pid.oldbin，然后用新的可执行文件启动一个新的nginx主进程和对应的工作进程，并新建一个新的nginx.pid保存新的主进程号。\n\n平滑升级也可以通过执行 make upgrade。\n\n\n\n优雅关闭旧的工作进程\n\ntxtkill -WINCH `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n旧的主进程号收到WINCH信号后，将旧进程号管理的旧的工作进程优雅的关闭。即一段时间后旧的工作进程全部关闭，只有新的工作进程在处理请求连接。这时，依然可以恢复到旧的进程服务，因为旧的进程的监听socket还未停止。\n\n\n\n中途停止升级，回滚到旧的nginx\n\ntxtkill -HUP `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n给旧的主进程号发送HUP命令，此时nginx不重新读取配置文件的情况下重新启动旧主进程的工作进程。\n\n\n\n升级完成，退出旧的主进程。\n\ntxtkill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n给旧的主进程发送QUIT信号后，旧的主进程退出，并移除logs&#x2F;nginx.pid.oldbin文件，nginx的升级完成。\n\n\n\n\n\n安装模块在nginx源码目录下运行。\ntxt./configure --add-module=模块目录\nmake备份低版本nginx可执行文件，将objs目录下编译生成的高版本nginx复制到低版本nginx安装路径下的sbin目录下。\n全新安装执行：\ntxtmake install平滑升级执行：\ntxtmake upgrade \nmake clean \n配置连接数worker_processes：表示开启nginx的worker进程的个数，nginx启动会开两种进程，master进程用来管理调度，worker进程用来处理请求；\n上面表示两种设置方法，比如\n方法一：worker_processes auto;\n　　表示设置服务器cpu核数匹配开启nginx开启的worker进程数\n　　查看cpu核数：cat &#x2F;proc&#x2F;cpuinfo\n方法二：nginx设置cpu亲和力\n　　worker_processes 8;\n　　worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;\n　　00000001表示启用第一个CPU内核，00000010表示启用第二个CPU内核，以此类推\nworker_cpu_affinity：表示开启八个进程，第一个进程对应着第一个CPU内核，第二个进程对应着第二个CPU内核，以此类推。\n这种设置方法更高效，因将每个cpu核提供给固定的worker进程服务，减少cpu上下文切换带来的资源浪费。\n\nlocation配置详解\n语法规则： 指令 前缀 uri\n\n\nlocation [=|~|~*|^~] /uri/ &#123; … &#125;\n\n\n\n\nlocation区分普通匹配和正则匹配\n\n用前缀 “” 和 “”修饰的为正则匹配~   前缀表示区分大小写的正则匹配~  前缀表示不区分大小写的正则匹配\n除上面修饰的前缀（“&#x3D;” 和 “^”，或没有前缀修饰）都为普通匹配&#x3D;   前缀表示精确匹配^  前缀表示uri以某个常规字符串开头，可以理解为url的普通匹配\n\n\n匹配的原则\n\n普通匹配：优先原则—-&gt;最大前缀匹配原则; 顺序无关\n正则匹配：为顺序匹配，优先原则：谁在前面 就匹配谁；顺序相关\n如果location有普通匹配也有正则匹配，那匹配的原则为：\n首先匹配 &#x3D;，其次匹配^~, 其次是按文件中顺序的正则匹配，不带前缀普通匹配，最后是交给 &#x2F; 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。\n\n\n\n\n负载均衡nginx实现负载均衡原理，用户访问首先访问到nginx服务器，然后nginx服务器再从应用服务器集群中选择压力比较小的服务器，然后将该访问请求引向该服务器。如应用服务器集群中某一台服务器崩溃，那么从待选择服务器列表中将该服务器删除，也就是说一个服务器崩溃了，那么nginx服务器不会把请求引向到该服务器。\ntxtserver &#123;\n    listen       80;\n    server_name  192.168.50.1;\n     location / &#123;\n        proxy_pass http://test;\n    &#125;\n&#125;\n随机轮询\n\ntxtupstream test &#123;\n    server 192.168.5.140:8080;\n    server 192.168.5.141:8080;\n&#125;\n\n\n\n权重\n\ntxtupstream test &#123;\n    server 192.168.5.140:8080 weight=5;\n    server 192.168.5.141:8080 weight=10;\n&#125;\n\n\nip_hash\n\ntxtupstream test &#123;\n    ip_hash;\n    server 192.168.5.140:8080;\n    server 192.168.5.141:8080;\n&#125;\n\n\n\n\nnginx全局变量\n$args ：                     #这个变量等于请求行中的参数，同$query_string\n$content_length ：    #请求头中的Content-length字段。\n$content_type ：       #请求头中的Content-Type字段。\n$document_root ：   #当前请求在root指令中指定的值。\n$host ：                     #请求主机头字段，否则为服务器名称。\n$http_user_agent ：  #客户端agent信息\n$http_cookie ：          #客户端cookie信息\n$limit_rate ：              #这个变量可以限制连接速率。\n$request_method ：   #客户端请求的动作，通常为GET或POST。\n$remote_addr ：         #客户端的IP地址。\n$remote_port ：          #客户端的端口。\n$remote_user ：         #已经经过Auth Basic Module验证的用户名。\n$request_filename ： #当前请求的文件路径，由root或alias指令与URI请求生成。\n$scheme ：                #HTTP方法（如http，https）。\n$server_protocol ：    #请求使用的协议，通常是HTTP&#x2F;1.0或HTTP&#x2F;1.1。\n$server_addr ：         #服务器地址，在完成一次系统调用后可以确定这个值。\n$server_name ：       #服务器名称。\n$server_port ：          #请求到达服务器的端口号。\n$request_uri ：          #包含请求参数的原始URI，不包含主机名，如：”&#x2F;foo&#x2F;bar.php?arg&#x3D;baz”。\n$uri ：                        #不带请求参数的当前URI，$uri不包含主机名，如”&#x2F;foo&#x2F;bar.html”。\n$document_uri ：      #与$uri相同\n\n\n附录：配置文件nginx#以哪个用户，运行nginx应用\n#nobody是个低权限用户，为了安全\n#user nobody;\n\n#nginx进程数 启动进程,通常设置成 cpu的核数 查看cpu核数\n# cat /proc/cpuinfo\nworker_processes  1;\n\n#全局错误日志 \n#nginx的error_log类型如下（从左到右：debug最详细 crit最少）： \n#[ debug | info | notice | warn | error | crit ] \n#例如：error_log logs/nginx_error.log  crit; \n#解释：日志文件存储在nginx安装目录下的 logs/nginx_error.log ，错误类型为 crit ，也就是记录最少错误信息； \nerror_log  logs/error.log;\nerror_log  logs/notice.log  notice;\nerror_log  logs/info.log  info;\n\n#PID文件，记录当前启动的nginx的进程ID\npid        logs/nginx.pid;\n\n#这个参数表示worker进程最多能打开的文件句柄数，基于liunx系统ulimit设置\n#查看系统文件句柄数最大值：ulimit -n\n#Linux一切皆文件，所有请求过来最终目的访问文件，所以该参数值设置等同于liunx系统ulimit设置为优\n#可以通过linux命令设置  最大的文件句柄数65535\nworker_rlimit_nofile 65535;\n\n#工作模式及连接数上限\nevents &#123;\n   #网络模型高效(相当于建立索引查找结果)，nginx配置应该启用该参数\n   #但是仅用于linux2.6以上内核,可以大大提高nginx的性能\n   use   epoll;             \n   #该参数表示设置一个worker进程最多开启多少线程数\n   #优化设置应该等同于worker_rlimit_nofile设置值，表明一个线程处理一个http请求，同时可以处理一个文件数，各个模块之间协调合作不等待。\n   worker_connections  65535;\n&#125;\n\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\nhttp &#123;\n    #设定mime类型,类型由mime.type文件定义\n    #MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来#打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n    #设定日志格式\n    log_format  main  &#39;[$remote_addr] - [$remote_user] [$time_local] &quot;$request&quot; &#39;\n        &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n        &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n    access_log    /var/log/nginx/access.log;\n\n    #sendfile 开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n    sendfile        on;\n    tcp_nopush     on; #防止网络阻塞\n    tcp_nodelay        on; #防止网络阻塞\n\n    #连接超时时间\n    #keepalive_timeout  0;  \n    keepalive_timeout  65; #长连接超时时间，单位是秒\n\n    #开启gzip压缩\n    gzip  on;\n    gzip_disable &quot;MSIE [1-6]\\.&quot;; # IE6及以下禁止压缩 \n    gzip_min_length 1k; #最小压缩文件大小\n    gzip_buffers 4 16k; #压缩缓冲区\n    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n    gzip_comp_level 2; #压缩等级\n    gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型\n    gzip_vary on; #给CDN和代理服务器使用，针对相同url，可以根据头信息返回压缩和非压缩副本\n\n    #设定请求缓冲\n    client_header_buffer_size    1k;   #上传文件大小限制\n    large_client_header_buffers  4 4k;  #设定请求缓存\n\n    #设定负载均衡的服务器列表\n    upstream mysvr &#123;\n        #weigth参数表示权值，权值越高被分配到的几率越大\n        server 192.168.8.1x:3128 weight=5;\n        server 192.168.8.2x:80  weight=1;\n        server 192.168.8.3x:80  weight=6;\n    &#125;\n\n    upstream mysvr2 &#123;\n        #weigth参数表示权值，权值越高被分配到的几率越大\n        server 192.168.8.x:80  weight=1;\n        server 192.168.8.x:80  weight=6;\n    &#125;\n\n    #虚拟主机的配置\n    server &#123;\n        #侦听80端口\n        listen       80;\n        #设置编码\n        #charset koi8-r;\n\n        #定义使用www.xx.com访问 域名可以有多个，用空格隔开\n        server_name  www.xx.com;\n\n        #设定本虚拟主机的访问日志\n        access_log  logs/www.xx.com.access.log  main;\n\n        #默认请求\n        location / &#123;\n            root   /root;      #定义服务器的默认网站根目录位置\n            index index.php index.html index.htm;   #定义首页索引文件的名称\n\n            proxy_pass  http://mysvr ;#请求转向mysvr 定义的服务器列表\n\n            client_max_body_size 10m;    #允许客户端请求的最大单文件字节数\n            client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数，\t\n\n            #以下是一些反向代理的配置可删除.\n\n            proxy_redirect off;\n\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_connect_timeout 90;  #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_send_timeout 90;     #后端服务器数据回传时间(代理发送超时)\n            proxy_read_timeout 90;     #连接成功后，后端服务器响应时间(代理接收超时)\n            proxy_buffer_size 4k;      #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            proxy_buffers 4 32k;       #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置\n            proxy_busy_buffers_size 64k;    #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n\n        &#125;\n\n        # 定义错误提示页面\n        error_page   500 502 503 504 /50x.html; \n        location = /50x.html &#123;\n            root   /root;\n        &#125;\n\n        #本地动静分离反向代理配置\n        #所有jsp的页面均交由tomcat处理\n        location ~ .(jsp|jspx|do)?$ &#123;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://127.0.0.1:8080;\n        &#125;\n\n        #静态文件，nginx自己处理\n        location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;\n            root /var/www/virtual/htdocs;\n            #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。\n            expires 30d;\n        &#125;\n\n        #设定查看Nginx状态的地址\n        location /NginxStatus &#123;\n            stub_status            on;\n            access_log             on;\n            auth_basic             &quot;NginxStatus&quot;;\n            auth_basic_user_file  conf/htpasswd;\n            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。\n        &#125;\n        #禁止访问 .htxxx 文件\n        location ~ /\\.ht &#123;\n            deny all;\n        &#125;\n\n    &#125;\n&#125;\n","slug":"Nginx-学习记录","date":"2023-10-16T14:50:22.000Z","categories_index":"","tags_index":"Nginx","author_index":"Aurora"},{"id":"79b60e240085d4bb70ab66eeea0e147e","title":"测试文章","content":"第一章内容。\n\n第二章内容。\n\n内容结束。\n","slug":"测试文章","date":"2023-10-16T14:04:05.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deployMore info: Deployment\n","slug":"hello-world","date":"2023-10-16T13:47:37.421Z","categories_index":"","tags_index":"","author_index":"Aurora"}]